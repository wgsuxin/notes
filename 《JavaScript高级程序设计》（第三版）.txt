//
第 1 章===============================================================
1、1995 年 2 月发布的 Netscape Navigator 2 开发名为 LiveScript 的脚本语言，它在服务器上的名字叫 LiveWire，Netscape 为了搭上媒体热炒 Java 的顺风车，发布前夕为了搭上当时热炒的 Java 临时把 LiveScript 改名为 JavaScript；1996 年，Netscape Navigator 3 捆绑发布了 JavaScript 1.1；1997 年，内置 JavaScript 1.2 的 Netscape Navigator 4 发布；Netscape 6 以后改为 Mozilla，Netscape 7 以后重心转向 Firefox，在 2004 年后 Firefox 强势崛起
2、IE 对 JavaScript （ECMAScript）的实现——JScript 是基于 Netscape JavaScript 1.0 开发，于 1996 年 8月随同 Internet Explorer 3.0 发布
3、1997 年，以 JavaScript 1.1 为蓝本的建议被提交给了欧洲计算机制造商协会（ECMA，European Computer Manufacturers Association）。该协会指定 39 号技术委员会（TC39，Technical Committee #39）负责“标准化一种通用、跨平台、供应商中立的脚本语言的语法和语义”
4、TC39 制定了 ECMA-262——定义一种名为 ECMAScript（发音为“ek-ma-script”）的新脚本语言的标准
5、1998 年 ISO/IEC（International Organization for Standardization and International Electrotechnical Commission，国标标准化组织和国际电工委员会）也采用了 ECMAScript 作为标准（即 ISO/IEC-16262）
6、完整的 JavaScript 实现分为三部分： 核心（ECMAScript，提供核心语言功能）、文档对象模型（DOM，提供与网页交互的方法和接口）、 浏览器对象模型（BOM，提供与浏览器交互的方法和接口）
7、Web 浏览器只是 ECMAScript 实现可能的宿主环境之一
8、ECMA-262 标准规定了语言的如下组成部分：语法、类型、语句、关键字、保留字、操作符、对象
9、ECMAScript 3.1 成为 ECMA-262 第 5 版，并于 2009 年 12 月 3 日正式发布
10、DOM1 级（DOM Level 1）于 1998 年 10 月成为 W3C（World Wide Web Consortium，万维网联盟） 的推荐标准。DOM1 级由两个模块组成：DOM 核心（DOM Core）和 DOM HTML
11、DOM2 级在 DOM1 基础上扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 文档的方法）等细分模块，而且通过对象接口增加了对 CSS（Cascading Style Sheets，层叠样式表）的支持
12、DOM3 扩展了DOM 加载和保存（DOM Load and Save）模块、新增了 DOM 验证（DOM Validation）模块、开始支持 XML 1.0 规范，Firefox 1完全支持 DOM1 级及DOM2 级，IE5.5、IE6、IE7 仅支持 DOM1 级，IE8 修复 bug，IE9+ 支持 DOM3
13、浏览器对象模型（BOM，Browser Object Model）表示访问和操作浏览器窗口及所有针对浏览器的 JavaScript 扩展

第 2 章================================================================
1、HTML 4.01 <script> 定义了 6 个属性： async charset defer language（已废弃） src type
2、使用 <script> 两种方式：内嵌 JS 代码，用 src 包含外部 JS 文件
3、内嵌方式代码中不能出现 </script> 字串，此串代表 script 块结束，后面还有代码的话解析会报错，可用转义字符“/”解决此问题如下所示： "<\/script>"
4、包含外部 JS 文件必须使用 src 属性，文件一般为 .js 后缀名，不过解析器不检查后缀，所以使用 .php 等也没问题，文件内代码不需要添加 <script> 标签了，使用了src后内嵌代码会被忽略
5、浏览器会按照 <script> 元素在页面中出现的先后顺序对它们依次进行下载、解析、执行（包含 defer async 例外）
6、延迟脚本属性 defer 只适用于外部脚本文件，表明立即下载但延迟执行，一般是在页面解析完毕后 DOMContentLoaded 事件触发前执行，不过一个页面最好只包含一个延迟脚本，多个时实际运行结果不可预料
7、异步脚本属性 async 也仅用于外部脚本，会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行，多个时不保证先后顺序执行
8、脚本位置一般放在 body 标签前，这样不会阻止界面呈现
9、要包含不需要解析内容可以使用 CData 片段，示例：<![CDATA[ 非解析内容 ]]>
10、为了兼容较早的浏览器能正常解析 <script> 标签，使用 <script><!-- 开头，//--></script> 结尾
11、采用外部文件优势：提高维护性、使浏览器缓存提高访问速度、更容易扩展以适应未来其他需求
12、IE 5.5引入文档模式，通过 doctype 切换，最初包含 混杂模式（quirks mode）和标准模式（standards mode）
13、为了使浏览器不支持或禁用了 JavaScript 时平稳退化，采用 <noscript> 标签显示替代内容

第 3 章================================================================
1、语言的核心都必然会描述这门语言最基本的工作原理，包含语法、操作符、数据类型、内置功能等
2、语法：ECMAScript 中的一切（变量、函数名和操作符）都区分大小写
3、语法：标识符（或者叫变量名，ECMAScript 惯例标识符采用驼峰大小写，以字母、下划线、美元符开头，可包含数字、字母、下划线、美元符以及扩展的 ASCII或 Unicode字母字符（如 À和 Æ，但不推荐），另外不能使用 关键字、保留字、 true 、 false 和 null 等语言本身已经使用的字符串）
4、语法：注释（使用类 C 风格的注释，包括单行注释和块级注释）
5、语法：ECMAScript 5 引入了严格模式（strict mode）的概念，如要启用严格模式，需要在文件顶部（作用于整个文件）或函数内部上方（仅作用于该函数）添加： "use strict";
6、语法：语句一般以一个分号结尾，省略分号则由解析器确定语句结尾；
7、关键字（即用于本身语法的某些单词或字串）和保留字（即在这门语言中还没有任何特定的用途，但可能会在将来被用作关键字）
8、变量可以用来保存任何类型的数据
9、给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误
10、检测给定变量的数据类型可以用 typeof 操作符，见 3.4.1 节
11、包含 undefined 值的变量与尚未定义的变量是不一样的，具体来说如果变量是 undefined 则可以进行各种操作，而未定义的变量只能使用 typeof 检测数据类型，用于任何其他操作都会导致“ReferenceError：is not defined”错误，但是通过 typeof 检测都是 'undefined'
12、null 值表示一个空对象指针，所以使用 typeof 操作符检测 null 值时会返回 "object"
13、实际上， undefined 值是派生自 null 值，因此 ECMA-262规定对它们的相等性测试要返回 true 
14、Boolean 类型转换规则参见 3.4.4 节
15、Number 类型使用 IEEE754 格式来表示整数和浮点数值（浮点数值的最高精度是 17 位小数，会有舍入误差，如计算 0.1 + 0.3 结果不是 0.3，而是 0.30000000000000004）
16、八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的数值超出了范围（如09），那么前导零将被忽略，后面的数值将被当作十进制数值解析，八进制字面量在严格模式下无效会导致错误
17、十六进制字面值的前两位必须是 0x，后跟任何十六进制数字（0～9 及 A～F）
18、n/a（或N/A），是 not applicable 的缩写，意思是“不适用”
19、浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字
20、var floatNum3 = .1; // 有效，但不推荐
21、var floatNum2 = 10.0; // 整数——解析为 10
22、ECMAScript 能够表示的最小、最大数值分别保存在 Number.MIN_VALUE Number.MAX_VALUE 中，详见 3.4.5 第 2 节
23、特殊的数值 Infinity（正无穷） -Infinity（负无穷） NaN（非数值）
24、有 3 个函数可以把非数值转换为数值： Number() 、 parseInt() 和 parseFloat()，规则详见 3.4.5 第 4 节
25、要把一个值转换为一个字符串有两种方式： toString() 方法和转型函数 String()，详见 3.4.6 第 3 节
26、在 ECMAScript 中 Object 是所有对象的基础，属性方法详见 3.4.7 节，不过不一定适用于 JavaScript 宿主对象
27、用于操作数据值的符号称为操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符，能够适用于很多值，例如字符串、数字值、布尔值，甚至对象
28、对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数
29、正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂，没有用到的位以 0 填充
30、负数同样以二进制码存储，但使用的格式是二进制补码
31、计算一个数值的二进制补码，需要经过 3 个步骤：1、求绝对值 2、求二进制反码 3、加 1
32、按位非（~）操作的本质：操作数的负值减 1
33、按位与（ & ）操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0
34、按位或（|）操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0的情况下才返回 0
35、按位异或（^）操作在两个数值对应位上只有一个 1 时才返回 1，如果两位一样都是 1 或都是 0，则返回 0
36、左移，有符号右移，无符号右移
37、逻辑非（!）操作符可用于任何数据类型的值，都会返回一个布尔值
38、逻辑与（&&）操作可以应用于任何类型的操作数，当有一个操作数不是布尔值时，不一定会返回布尔值，详见 3.5.3 第 2 节
39、在对非数值应用一元操作符时，该操作符会像 Number() 转型函数一样对这个值执行转换
40、对非数值应用位操作符，会先使用 Number() 函数将该值转换为一个数值
41、乘性计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值
42、加操作符计算结果可能是数值或字符串，减操作符只会是数值
43、小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个操作符都返回一个布尔值（操作数都是字符串时是按字符编码值进行比较）
44、任何操作数与 NaN 进行关系比较，结果都是 false（NaN < 3 结果为 false，NaN >= 3 结果也为 false）
45、相等和不相等——先转换再比较，全等和不全等——仅比较而不转换，具体转换规则详见 3.5.7 节
46、使用复合赋值（+= -= *=）操作符不会带来任何性能的提升
47、逗号操作符在用于赋值时，总会返回表达式中的最后一项
48、语句：if  do-while  while  for  for-in  label  break/continue  with  switch-case
49、可以在 switch 语句中使用任何数据类型，每个 case 的值可以是常量、变量或表达式
50、switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换
51、ECMAScirpt 函数没有签名，可以传递任意数量的参数，并且可以通过 arguments 对象来访问，没有传递值的命名参数将自动被赋予 undefined 值
52、ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数

第 4 章========================================================================================
1、Undefined、Null、Boolean、Number 和 String 这 5 种基本数据类型是按值访问的
2、函数参数按值传递 function setName(obj) { obj.name = "Nicholas"; obj = new Object(); obj.name = "Greg"; }
   var person = new Object(); setName(person); alert(person.name); //"Nicholas"
3、检测基本数据类型时 typeof 是非常得力的助手，检测引用类型的值使用 instanceof 操作符
4、执行环境（execution context，有时也称为“环境”、“环境上下文”）是 JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为
5、每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中
6、全局执行环境是最外围的一个执行环境
7、 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链（scope chain）
8、作用域链的前端，始终都是当前执行的代码所在环境的变量对象
9、如果这个环境是函数，则将其活动对象（activation object）作为变量对象
10、活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）
11、标识符解析是沿着作用域链一级一级（从内向外或从下向上）地搜索标识符的过程
12、执行环境的类型总共只有两种——全局和局部（函数）
13、try-catch 语句的 catch 块、with 语句都会在作用域链的前端添加一个变量对象来延长作用域链
14、JavaScript 没有块级作用域
15、JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）
16、另一种垃圾收集算法是“引用计数”，当代码中存在循环引用现象时，“引用计数”算法就会导致问题

第 5 章========================================================================================
1、对象是某个特定引用类型的实例，新对象是使用 new 操作符后跟一个构造函数来创建的
2、创建 Object 实例的方式：使用 new 操作符后跟 Object 构造函数，使用对象字面量表示法即 {}
3、在 JavaScript 可以使用点表示法或方括号表示法来访问对象的属性，建议使用点表示法
4、在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中
5、创建 Array 实例的方式：使用 Array 函数（可以省略 new），使用数组字面量表示法即 []
6、与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数
7、通过设置数组的 length 属性，可以从数组的末尾移除项或向数组中添加新项
8、数组最多可以包含 4 294 967 295 个项（截止到 ES5）
9、ECMAScript 5 新增了 Array.isArray() 方法用于最终确定某个值到底是不是数组
10、对于只有一个网页或者一个全局作用域而言，使用 instanceof 操作符即可检测变量（的值的）类型是否数组
11、如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，即每个框架页里的 Array 也是不同的
12、数组的 toString() 方法与 join() 方法效果一致
13、栈是一种 LIFO（Last-In-First-Out，后进先出）的数据结构（使用 push() 和 pop() 实现）
14、队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）（使用 push() 和 shift() 方法）
15、在数组前端添加项 unshift()，排序方法 reserve()（反转顺序），sort()（可接收一个函数见 5.2.5 节）
16、数组项操作方法：concat() 合并，slice() 截取（不会影响原数组），splice()（会影响原数组）（详见 5.2.6 节）
17、数组查找项的方法： indexOf() 和 lastIndexOf()
18、迭代方法：every()，filter()，forEach()，map() ，some()
19、归并数组的方法： reduce() 和 reduceRight()（详见 5.2.9 节）
20、ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的
21、 Date 类型使用自 UTC（Coordinated Universal Time，国际协调时间，由于英文 CUT 与法文 TUC 缩写不一致，折中为UTC）1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期
22、使用这种数据存储格式， Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285 616 年
23、Date 对象涉及的方法详见 5.3.3 节
24、RegExp 类型用于正则表达式，语法为：var expression = / pattern / gim ;
25、在 ECMAScript 3 中正则表达式字面量始终会共享同一个 RegExp 实例，而使用构造函数每次会创建一个新 RegExp 实例，ECMAScript 5 已规定为两种方式一致，即每次都创建新的 RegExp 实例
26、RegExp 支持的方法详见 5.4.3 节，有一些高级特性不支持详见 5.4.4 节
27、函数是对象，函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同
28、除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的
29、函数内部有两个特殊的对象：arguments 和 this，还有个 caller 属性保存着调用当前函数的函数的引用
30、arguments 的主要用途是保存函数参数，不过有个 callee 的属性是一个指针，指向拥有这个 arguments 对象的函数
31、自动创建的基本包装类型的对象只存在于一行代码的执行瞬间，然后立即被销毁
32、使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的
33、理解基本类型的布尔值与 Boolean 对象之间的区别非常重要，建议是永远不要使 用 Boolean 对象
34、两个用于访问字符串中特定字符的方法是： charAt() 和 charCodeAt()
35、字符串操作方法 concat() slice() 、 substr() 和 substring() 都不会修改字符串本身的值
36、查找子字符串的方法： indexOf() 和 lastIndexOf()
37、trim() toLowerCase() 、 toLocaleLowerCase() 、 toUpperCase() 和 toLocaleUpperCase()
38、模式匹配方法 match() 本质上与调用 RegExp 的 exec() 方法相同， search() replace() split()
39、localeCompare() ，这个方法比较两个字符串
40、String 构造函数本身还有一个静态方法： fromCharCode()
41、没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性，如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat()
42、URI 方法 encodeURI() 、 encodeURIComponent() 、 decodeURI() 和 decode-URIComponent() 能够编码所有 Unicode字符
43、当解析器发现代码中调用 eval() 方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置
44、特殊的值 undefined 、 NaN 、 Infinity 及所有原生引用类型的构造函数（如 Object Boolean Date）都是 Global 对象的属性（详见 5.7.1 节第 3 小节）
45、 Math 对象的属性方法 Math.min() max() ceil() floor() round() random()（详见 5.7.2 节）


第 6 章========================================================================================
1、对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数
2、ECMAScript 5 定义了只有内部才用的特性（attribute），描述了属性（property）的各种特征（详见 6.1.1 节）
3、几个跟属性有关的方法 Object.defineProperty() Object.defineProperties() Object.getOwnPropertyDescriptor()
4、创建对象的几种模式（详见 6.2 各小节）
5、任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数
6、 prototype 属性是不可枚举的，因此使用 for-in 无法发现
7、每个函数都包含两个非继承方法： apply() 和 call() 用途都是在特定的作用域中调用函数
8、函数都有一个 prototype （原型）属性，这个属性是一个指针，指向一个包含了实例属性和方法的对象
9、创建一个新函数就会创建一个 prototype 属性，这个属性指向函数的原型对象，而原型对象都会自动获得一个 constructor （构造函数）属性，这个属性指向 prototype 属性所在函数的指针
10、调用构造函数创建的新实例的内部将包含一个指针（内部属性 [[Prototype]]），指向构造函数的原型对象
11、给对象实例添加一个属性时，这个属性会屏蔽原型对象中保存的同名属性（通过原型链搜索机制解释此问题）
12、使用 delete 操作符删除实例属性可以恢复对原型中同名属性的读取
13、使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中（true），还是存在于原型中（false）
14、单独使用 in 操作符会在通过对象能够访问给定属性时返回 true
15、ECMAScript 5 的 Object.keys() 方法可以取得对象上所有可枚举的实例属性
16、使用 Object.getOwnPropertyNames() 方法得到所有实例属性，无论它是否可枚举
17、原型链是实现继承的主要方法，即让一个类型的实例作为另一个类型的原型
18、组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式
19、寄生式组合继承集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式


第 7 章========================================================================================
1、定义函数的方式有两种：一种是函数声明，另一种就是函数表达式
2、函数声明的一个重要特征就是函数声明提升（function declaration hoisting）即在执行代码之前会先读取函数声明
3、类似变量声明方式创建的函数叫做匿名函数（anonymous function），因为 function 关键字后面没有标识符
4、匿名函数有时候也叫拉姆达函数
5、疑问？(object.getName = object.getName)(); //"The Window"，在非严格模式下 第 7.2.2 节最后一段
6、JavaScript 中多次声明同一个变量时，后续的声明会被忽略，不过后续声明中的变量初始化会正常执行
7、可以使用立即执行函数模拟块级作用域


第 8 章========================================================================================
1、BOM 提供的对象用于访问浏览器的功能，这些功能与任何网页内容无关
2、定义全局变量与在 window 对象上直接定义属性有一点差别：全局变量不能通过 delete 操作符删除
3、如果页面中包含框架，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中
4、在 frames 集合中，可以通过数值索引（从 0 开始，从左至右，从上到下）或者框架名称来访问相应的 window 对象
5、每个 window 对象都有一个 name 属性，其中包含框架的名称
6、与框架（frames）有关的几个对象： top 对象始终指向最高（最外）层的框架，也就是浏览器窗口
7、parent （父）对象始终指向当前框架的直接上层框架
8、self 始终指向 window ；实际上， self 和当前框架中的 window 对象可以互换使用
9、window.open() 需要多看看，使用详见 8.1.5 节
10、window.open() 方法会返回一个指向新窗口的引用
11、新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象
12、间歇调用 setInterval() 超时调用 setTimeout() 方法
13、浏览器通过 alert() 、 confirm() 和 prompt() 方法可以调用系统对话框向用户显示消息
14、系统对话框与在浏览器中显示的网页没有关系，也不包含 HTML，并且外观由操作系统及（或）浏览器设置决定
15、通过这几个方法打开的对话框都是同步和模态的，也就是说显示这些对话框的时候代码会停止执行
16、location 是最有用的 BOM 对象之一，它提供了与当前窗口中加载的文档有关的信息及导航功能，详见 8.2 节
17、location 对象是一个别的对象，因为它既是 window 对象的属性，也是 document 对象的属性
18、navigator 对象详见 8.3 节
19、history.go()  history.back()  history.forward()


第 9 章========================================================================================
1、最常用也最为人们广泛接受的客户端检测形式是能力检测（又称特性检测）
2、能力检测的基本模式如下：if (object.propertyInQuestion) { //使用 object.propertyInQuestion }
3、先检测达成目的的最常用的特性，第二就是必须测试实际要用到的特性
4、要尽量使用 typeof 进行能力检测
5、能力检测，不是浏览器检测
6、怪癖检测（quirks detection）的目标是识别浏览器的特殊行为
7、第三种，也是争议最大的一种客户端检测技术叫做用户代理检测
8、用户代理检测通过检测用户代理字符串来确定实际使用的浏览器，完整代码见 9.3.3 节


第 10 章 DOM ========================================================================================
1、

第 11 章 DOM 扩展========================================================================================

第 12 章 DOM2 和 DOM3 ===================================================================================
offsetHeight ：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度
offsetWidth ：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度
offsetLeft ：元素的左外边框至包含元素的左内边框之间的像素距离
offsetTop ：元素的上外边框至包含元素的上内边框之间的像素距离
clientWidth 属性是元素内容区宽度加上左右内边距宽度
clientHeight 属性是元素内容区高度加上上下内边距高度



第 13 章 事件 ========================================================================================
1、IE 的事件流叫做事件冒泡（event bubbling）即事件由下向上传播
2、Netscape 团队提出的另一种事件流叫做事件捕获（event capturing），事件由上向下传播，用意在于中途可以截获
3、“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段（一般多用冒泡阶段）
4、事件处理程序的名字以 "on" 开头，如 click 事件的事件处理程序就是 onclick
5、为事件指定处理程序的方式第一种为：HTML事件处理程序，即在 html 标签填写相关特性值
6、第二种为 DOM0 级事件处理程序，即 js 赋值事件属性，如：btn.onclick = function(){}
7、第三种为 DOM2 级事件处理程序即监听器指定，btn.addEventListener("click", function(){})
8、后面两种事件处理程序是在所绑定元素的作用域中运行
9、IE事件处理程序 attachEvent() 和 detachEvent()
10、在触发 DOM 上的某个事件时，会产生一个事件对象 event ，包含着所有与事件有关的信息
11、event 对象包含的特定事件有关的属性和方法详见 13.3.1 小节
12、要阻止特定事件的默认行为，可以使用 preventDefault() 方法，即 event.preventDefault()
13、要停止事件在 DOM 层次中的传播使用 stopPropagation() 方法
14、event 对象只在事件处理程序执行期间才存在，事件处理程序一旦执行完成 event 对象即被销毁
15、跨浏览器事件对象处理详见 13.2.5 及 13.3.3 小节
16、“DOM3 级事件”规定的事件类型：UI事件 焦点事件 鼠标事件 滚轮事件 文本事件 键盘事件 合成事件 变动（mutation）事件
17、复合事件（composition event）是 DOM3 级事件中新添加的一类事件，用于处理 IME（Input Method Editor，输入法编辑器）的输入序列
18、DOMContentLoaded 事件在形成完整的 DOM 树之后就会触发，不管 img、JavaScript、CSS 文件或其他资源是否已经下载完毕
19、“事件处理程序过多”可能导致性能问题（内存占用多，DOM访问次数多），可通过事件委托解决
20、btn.onclick = null; //在删除元素前最好先移除事件处理程序
21、可以在 document 对象上使用 createEvent() 方法创建 event 对象用于模拟事件


第 14 章 表单脚本 ========================================================================================
1、在 JavaScript 中，表单对应的是 HTMLForm-Element 类型，继承自 HTMLElement
2、提交按钮：input type="submit" button type="submit" input type="image"
3、当表单中存在提交按钮，在表单任一非 textarea 控件拥有焦点的情况下，按回车键就可以提交该表单
4、以上述方式提交表单时，浏览器会在将请求发送给服务器之前触发 submit 事件
5、在 JavaScript 中调用 form.submit() 方法的形式提交表单时，不会触发 submit 事件
6、解决重复提交问题：在第一次提交表单后就禁用提交按钮，或者利用 onsubmit 事件处理程序取消后续的提交操作
7、每个表单都有 elements 属性，该属性是表单中所有表单元素（字段）按出现顺序排列的集合
8、选择框的 change 事件只要选中了选项就会触发，其他表单字段的 change 事件是在值被修改且焦点离开当前字段时触发
9、表单序列化注意事项参见 14.4 小节
10、富文本编辑器知识详见 14.5 小节


第 15 章 使用 Canvas 绘图 ==================================================================================
1、在使用 <canvas> 元素之前，首先要检测 getContext() 方法是否存在


第 16 章 HTML5 脚本编程 ====================================================================================
1、跨文档消息传送（cross-document messaging），简称 XDM，指的是在来自不同域的页面间传递消息
2、拖放功能详见 16.2 节
3、多媒体包含 <audio> 和 <video> 两个标签，详见 16.3 节


第 17 章 错误处理与调试 ====================================================================================
1、ECMA-262 第 3 版引入了 try-catch 语句，作为 JavaScript 中处理异常的一种标准方式
2、catch 块会接收到一个包含错误信息的对象，即使你不想使用这个错误对象，也要给它起个名字
3、只要代码中包含 finally 子句，那么无论 try 还是 catch 语句块中的 return 语句都将被忽略
4、在明确知道出现什么情况代码会发生错误时，不应使用 try-catch 语句进行处理
5、throw 操作符，用于随时抛出自定义错误。抛出错误时，必须要给 throw 操作符指定一个值
6、任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件
7、要指定 onerror 事件处理程序，必须使用 DOM0 级技术代码如：window.onerror = function(message, url, line){}
8、在上面的事件处理程序中返回 false ，可以阻止浏览器报告错误的默认行为
9、一般需要关注三种错误：类型转换错误，数据类型错误，通信错误
10、基本类型的值应该使用 typeof 来检测，而对象的值则应该使用 instanceof 来检测
11、对于查询字符串，应该记住必须要使用 encodeURIComponent() 方法
12、提交给服务器处理的 js 代码可以使用 Image 对象来发送请求


第 18 章 JavaScript 与 XML ================================================================================
1、DOM2级在 document.implementation 中引入了 createDocument() 方法


第 19 章 E4X =============================================================================================
1、E4X（ECMAScript for XML）以 ECMA-357 标准的形式发布
2、E4X 本身不是一门语言，它只是 ECMAScript 语言的可选扩展


第 20 章 JSON =============================================================================================
1、JSON 最重要的是要理解它是一种数据格式，不是一种编程语言
2、并不是只有 JavaScript 才使用 JSON，很多编程语言都有针对 JSON 的解析器和序列化器
3、JSON 的语法可以表示三种类型的值：简单值，对象，数组；但不支持变量、函数或对象实例
4、JSON 中对象的属性名任何时候都必须加双引号
5、ECMAScript 5 对解析 JSON 的行为进行规范，定义了全局对象 JSON
6、JSON 对象有两个方法： stringify() 和 parse()
7、如果传给 JSON.parse() 的字符串不是有效的 JSON，该方法会抛出错误


第 21 章 Ajax 与 Comet ====================================================================================
1、Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR）
2、XHR 异步流程：指定 onreadystatechange 事件处理程序，调用 open()，调用 send()，在事件程序中处理
3、同步请求时可以检测 XHR 对象的状态属性 status，异步时检测 XHR 对象的 readyState 属性
4、在接收到响应之前可以调用 abort() 方法来取消异步请求
5、要成功发送请求头部信息，必须在调用 open() 方法之后且调用 send() 方法之前调用 setRequestHeader() 
6、调用 XHR 对象的 getResponseHeader() 方法并传入头部字段名称，可以取得相应的响应头信息
7、GET 是最常见的请求类型，最常用于向服务器查询某些信息
8、POST 请求通常用于向服务器发送应该被保存的数据
9、CORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通
10、图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式
11、JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，是应用 JSON 的一种新方法
12、有两种实现 Comet 的方式：长轮询和流
13、长轮询是传统轮询（也称为短轮询）的一个翻版
14、Ajax 安全很重要，CSRF（Cross-Site Request Forgery，跨站点请求伪造）


第 22 章 高 级 技 巧 ====================================================================================
1、调用 Object 原生的 toString() 方法可以检测原生类型，如 Object.prototype.toString.call(arr) == "[object Array]"

